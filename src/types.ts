// type of a function that gets passed to WizText and stuff
export interface Validation {
  message: string;
  rule: (value: string | number | selectOption | boolean) => boolean;
}

export type selectOption = {
  label: string;
  value: string | number;
};

/****  FIELD OBJECTS ****
  These babies are the actual objects that exist in form state. genWizardFormState generates object
  that have these as properties
*/
export interface TextField {
  value: string;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "text";
}

export interface NumberField {
  value: number | null;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "number";
}

export interface SelectField {
  value: any;
  label: string | null;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "select";
}

export interface BooleanField {
  value: Boolean;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "boolean";
}

export interface NonFieldBoolean {
  value: Boolean;
  fieldType: "nonFieldBoolean";
}

export interface DateField {
  value: number;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "date";
}

export type localId = string;

export type WizField =
  | TextField
  | NumberField
  | SelectField
  | BooleanField
  | NonFieldBoolean
  | DateField
  | localId;

/*************************
 * ARGUMENT OBJECTS
 * pass an object of these to genWizardFormState to make a default wizard form state
 **************************/
interface TextFieldArg {
  type: "text";
  value?: string | null | undefined;
}

interface NumberFieldArg {
  type: "number";
  value?: number | null | undefined;
}

interface SelectFieldArg {
  type: "select";
  value?: string | null | undefined;
  label?: string | null | undefined;
}

interface DateFieldArg {
  type: "date";
  value?: number | null | undefined;
}

interface BooleanFieldArg {
  type: "boolean";
  value?: boolean | null | undefined;
}

interface NonFieldBooleanArg {
  type: "nonFieldBoolean";
  value?: boolean | null | undefined;
}

interface localIdFieldArg {
  type: "localId";
}

export type SingleFieldArgument =
  | TextFieldArg
  | NumberFieldArg
  | SelectFieldArg
  | DateFieldArg
  | BooleanFieldArg
  | NonFieldBooleanArg
  | localIdFieldArg;

// a WizArg is anything value in the key-value pairs of a WizConfig object
export type WizArg =
  | SingleFieldArgument
  | Array<Record<string, SingleFieldArgument>>;

// this is the type for the object that gets fed into the generator, which then returns
// a WizardFormState
export interface WizConfig {
  [key: string]: WizArg | Array<WizConfig>;
}

// this is the type for a whole default form state. This gets generated by feeding a WizConfig
// into the form generator
export interface WizardFormState {
  [key: string]: WizField | Array<WizardFormState>;
}

interface WizUpdateArgs {
  accessor: Function;
  validations: Array<Validation>;
}

export interface UpdateTextFieldArgs extends WizUpdateArgs {
  newValue: string;
}

export interface UpdateNumberFieldArgs extends WizUpdateArgs {
  newValue: number;
}

export interface UpdateSelectFieldArgs extends WizUpdateArgs {
  newValue: { label: string; value: any };
}

export interface UpdateBooleanFieldArgs extends WizUpdateArgs {
  newValue: boolean;
}


export interface UpdateDateFieldArgs extends WizUpdateArgs {
  newValue: number;
}

// these are the functions and stuff that get returned by useWizard. I should figure out how to do generics with this biz
export interface WizardProperties {
  state: any;
  // the functions ending with "Field" are new. From now on we should consider
  // updateWizValue deprecated
  updateTextField: ({
    newValue,
    accessor,
    validations,
  }: UpdateTextFieldArgs) => void;
  updateNumberField: ({
    newValue,
    accessor,
    validations,
  }: UpdateNumberFieldArgs) => void;
  updateSelectField: ({
    newValue,
    accessor,
    validations,
  }: UpdateSelectFieldArgs) => void;
  updateDateField: ({
    newValue,
    accessor,
    validations,
  }: UpdateDateFieldArgs) => void;
  updateBooleanField: ({
    newValue,
    accessor,
    validations,
  }: UpdateBooleanFieldArgs) => void;
  updateNonFieldBoolean: ({
    newValue,
    accessor,
  }: {
    newValue: boolean;
    accessor: Function;
  }) => void;
  addSubForm: ({
    config,
    accessor,
  }: {
    config: WizConfig;
    accessor: Function;
  }) => void;
  removeSubForm: ({
    arrayAccessor,
    formId
  }: {
    arrayAccessor: Function;
    formId: string;
  }) => void;
  setValue: (accessor: Function, newValue: any) => void;
  setProperty: (
    parentAccessor: Function,
    propertyName: string,
    newProperty: any
  ) => void;
  setState: (newState: any) => void;
  toggleErrorsVisible: Function;
}

// short for "response property". Use this on object fields after parsing the JSON of an endpoint payload,
// since those could really be anything. Tyepscript will then remind you to handle all cases
export type resProperty = number | string | null | undefined;
