// type of a function that gets passed to WizText and stuff
export type validation = {
  message: string;
  rule: (value: string | number | selectOption | boolean) => boolean;
};

export type selectOption = {
  label: string;
  value: string | number;
};

/****  FIELD OBJECTS ****
  These babies are the actual objects that exist in form state. genWizardFormState generates object
  that have these as properties
*/
export interface TextField {
  value: string;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "text";
}

export interface NumberField {
  value: number | null;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "number";
}

export interface SelectField {
  value: any;
  label: string | null;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "select";
}

export interface BooleanField {
  value: Boolean;
  errors: string[];
  errorsVisible: boolean;
  fieldType: "boolean";
}

export type localId = string;

export type WizField =
  | TextField
  | NumberField
  | SelectField
  | BooleanField
  | localId;

/**********
 * ARGUMENT OBJECTS
 * pass an object of these to genWizardFormState to make a default wizard form state
 */
interface TextFieldArg {
  type: "text";
  value?: string | null | undefined;
}

interface NumberFieldArg {
  type: "number";
  value?: number | null | undefined;
}

interface SelectFieldArg {
  type: "select";
  value?: string | null | undefined;
  label?: string | null | undefined;
}

interface BooleanFieldArg {
  type: "boolean";
  value?: boolean | null | undefined;
}

interface localIdFieldArg {
  type: "localId";
}

export type SingleFieldArgument =
  | TextFieldArg
  | NumberFieldArg
  | SelectFieldArg
  | BooleanFieldArg
  | localIdFieldArg;

// a WizArg is anything value in the key-value pairs of a WizConfig object
export type WizArg =
  | SingleFieldArgument
  | Array<Record<string, SingleFieldArgument>>;

// this is the type for the object that gets fed into the generator, which then returns
// a WizardFormState
export interface WizConfig {
  [key: string]: WizArg | Array<WizConfig>;
}

// this is the type for a whole default form state. This gets generated by feeding a WizConfig
// into the form generator
export interface WizardFormState {
  [key: string]: WizField | Array<WizardFormState>;
}

interface WizUpdateArgs {
  accessor: Function;
  validations: Array<validation>;
}

export interface UpdateTextFieldArgs extends WizUpdateArgs {
  newValue: string;
}

export interface UpdateNumberFieldArgs extends WizUpdateArgs {
  newValue: number;
}

export interface UpdateSelectFieldArgs extends WizUpdateArgs {
  newValue: any;
}

export interface UpdateBooleanFieldArgs extends WizUpdateArgs {
  newValue: boolean;
}

// these are the functions and stuff that get returned by useWizard. I should figure out how to do generics with this biz
export interface WizardProperties {
  state: any;
  // the functions ending with "Field" are new. From now on we should consider
  // updateWizValue deprecated
  updateTextField: ({
    newValue,
    accessor,
    validations,
  }: UpdateTextFieldArgs) => void;
  updateNumberField: ({
    newValue,
    accessor,
    validations,
  }: UpdateNumberFieldArgs) => void;
  updateSelectField: ({
    newValue,
    accessor,
    validations,
  }: UpdateSelectFieldArgs) => void;
  updateBooleanField: ({
    newValue,
    accessor,
    validations
  }: UpdateBooleanFieldArgs) => void;
  updateWizValue: (
    newValue: string | number | boolean | selectOption,
    accessor: Function,
    validations?: Array<validation>
  ) => void;
  updateSelect: (
    newValue: any,
    accessor: Function,
    validations: Array<validation>
  ) => void;
  updateCheckbox: (newValue: boolean, accessor: Function) => void;
  addArrayElement: (
    createNewElement: Function,
    accessor: Function,
    args: any
  ) => void;
  addSubForm: ({
    config,
    accessor,
  }: {
    config: WizConfig;
    accessor: Function;
  }) => void;
  replaceArrayElement: (
    createNewElement: Function,
    accessor: Function,
    args: any,
    index: number
  ) => void;
  deleteArrayElement: (arrayAccessor: Function, localId: string) => void;
  setValue: (accessor: Function, newValue: any) => void;
  setProperty: (
    parentAccessor: Function,
    propertyName: string,
    newProperty: any
  ) => void;
  setState: (newState: any) => void;
  toggleErrorsVisible: Function;
}

// short for "response property". Use this on object fields after parsing the JSON of an endpoint payload,
// since those could really be anything. Tyepscript will then remind you to handle all cases
export type resProperty = number | string | null | undefined;
